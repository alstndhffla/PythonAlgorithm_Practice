[해시법]
검색 뿐만이 아니라 데이터의 추가/삭제도 효율적으로 수행할 수 있는 '해시법'
데이터를 저장할 위치 = 인덱스 를 간단한 연산으로 구하는 것을 말한다.

해시값을 인덱스로 하여 원소를 새로 저장한 배열이 해시 테이블이다.(해시값은 데이터를 접근할 때 기준이 된다)

데이터를 추가할 때 기존 원소의 인덱스들을 다 옮겨야 하는데(추가되는 원소를 기점으로)
삭제도 마찬가지.
이런 작업을 기존 인덱스가 아니라 해시값을 형평에 맞게 구해서 새로 배열하는 것이다.
새로 배치된 배열을 '해시테이블' 이라고 하고 그 안에 배치된 원소들을 '버킷' 이라 칭한다.
이런 과정을 '해시함수' 라고 하는데 해시값이 한쪽으로 치우치지 않고 고르게 분산된 값을 출력하도록 하는게 중요하다.
(생성한 해시값에 해당하는 원소가 여러개일 경우, '해시충돌' 발생한다. 그래서 이를 해결하기 위해)
    - 체인법(오픈 해시법) : 해시값이 같은 원소를 연결 리스트로 관리한다.
    - 오픈 주소법 : 빈 버킷을 찾을 때까지 해시를 반복한다.
    위 2가지를 사용한다.


[체인법]
만약 충돌이 전혀 발생하지 않는다면, 해시 함수로 인덱스를 찾는 것만으로 검색, 추가, 삭제가 대부분 완료되므로
시간복잡도는 모두 O(1) 이다. 한번에 다 하나씩 해결되기 때문에
해시 테이블을 충분히 크게 만들면 충돌발생을 억제할 수 있겠지만 이 방법은 메모리 자체를 낭비한다.
시간과 공간의 트레이드오프가 발생하는 셈...

충돌을 피하려면 해시 함수가 해시 테이블을 크기보다 작거나 같은 정수를 고르게 생성해야 한다.
따라서 해시 테이블의 크기는 소수를 선호한다.

- key 가 int 형일 경우
key(기존 배열이 원소)를 해시의 크기(capacity-해시 테이블의 총 길이)로 나눈 나머지를 해시값(해시테이블의 인덱스)으로 한다.

- key 가 int 형이 아닐 경우
문자열, 리스트, 클래스형 등 은 해시의 크기(capacity)로 나눌 수 없다. 그래서 표준 라이브러리로 형 변환을 해야 해시값을
얻을 수 있다.


[오픈 주소법]
해시 충돌이 발생할 때 해결하는 또 다른 방법.
충돌이 발생했을 때 재해시를 수행하여 빈 버킷을 찾는 방법을 말한다. -> 닫힌 해시법/선형탐사법(찾을때까지 계속 반복함) 이라
부른다.
각 버킷에 속성을 부여한다.
- 데이터 저장
- 비어있음
- 삭제완료

왜? 기존 해시과정을 통해서 계산한 해시값이 아니라 빈 버킷이 나올때까지 해시값을 변경했기 때문에
체인법처럼 해시값을 단번에 찾아서 삭제하지 못한다(해당 해시에 없을 수도 있기 때문)
